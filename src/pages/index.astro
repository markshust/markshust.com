---
import BaseHead from '../components/BaseHead.astro';
import Nav from '../components/Nav.astro';
import Hero from '../components/Hero.astro';
import DiagonalBand from '../components/DiagonalBand.astro';
import MarqueeTrack from '../components/MarqueeTrack.astro';
import WritingSection from '../components/WritingSection.astro';
import BuildingSection from '../components/BuildingSection.astro';
import TeachingSection from '../components/TeachingSection.astro';
import ArchiveSection from '../components/ArchiveSection.astro';
import Footer from '../components/Footer.astro';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const thisFile = fileURLToPath(import.meta.url);
const pagesDir = path.resolve(path.dirname(thisFile), '..', 'pages');
const srcPagesDir = pagesDir.includes('/dist/')
    ? pagesDir.replace('/dist/', '/src/')
    : pagesDir;
const postFiles = Object.keys(import.meta.glob('./*/**/*.{md,mdx}'));

const allPosts = postFiles
    .map(filePath => {
      const raw = fs.readFileSync(path.join(srcPagesDir, filePath), 'utf-8');
      const match = raw.match(/^---\n([\s\S]*?)\n---/);
      const frontmatter: Record<string, string> = {};
      if (match) {
        for (const line of match[1].split('\n')) {
          const [key, ...rest] = line.split(':');
          if (key && rest.length) {
            frontmatter[key.trim()] = rest.join(':').trim().replace(/^["']|["']$/g, '');
          }
        }
      }
      const segments = filePath.split('/');
      const year = segments[1];
      const month = segments[2];
      const day = segments[3];
      const slug = segments[4];
      const pubDate = `${year}-${month}-${day}`;
      return {
        url: `/${year}/${month}/${day}/${slug}/`,
        title: frontmatter.title || '',
        pubDate,
      };
    })
    .filter(p => p.title)
    .sort((a, b) => new Date(b.pubDate).valueOf() - new Date(a.pubDate).valueOf());

const latestPosts = allPosts.slice(0, 4).map(p => ({
  url: p.url,
  title: p.title,
  date: new Date(p.pubDate).toLocaleDateString('en-us', {
    year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC'
  }),
}));

const postsByYear: Record<string, Array<{ url: string; title: string; date: string; shortDate: string }>> = {};
for (const p of allPosts) {
  const year = p.pubDate.split('-')[0];
  if (!postsByYear[year]) postsByYear[year] = [];
  postsByYear[year].push({
    url: p.url,
    title: p.title,
    date: p.pubDate,
    shortDate: new Date(p.pubDate).toLocaleDateString('en-us', {
      month: 'short', day: 'numeric', timeZone: 'UTC'
    }),
  });
}
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <BaseHead
      title="Mark Shust â€” Builder, Writer, Teacher"
      description="Mark Shust builds artisanal software through craft, code, and architecture, and shares what he learns along the way."
    />
  </head>
  <body>
    <div class="site-wrapper">
      <Nav homepage={true} />
      <Hero />
      <DiagonalBand variant="1">
        <MarqueeTrack />
      </DiagonalBand>
      <WritingSection posts={latestPosts} />
      <DiagonalBand variant="2" />
      <BuildingSection />
      <TeachingSection />
      <ArchiveSection postsByYear={postsByYear} />
      <Footer />
    </div>
  </body>
</html>

<style>
  .site-wrapper {
    max-width: 2560px;
    margin: 0 auto;
    background: var(--dark);
    position: relative;
    overflow-x: hidden;
  }
</style>

<script>
(function() {
  'use strict';

  // Scroll reveal (IntersectionObserver)
  const revealEls = document.querySelectorAll('.reveal, .reveal-left, .reveal-right, .reveal-scale');
  const revealObs = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.classList.add('visible');
        revealObs.unobserve(e.target);
      }
    });
  }, { threshold: 0.12, rootMargin: '0px 0px -50px 0px' });
  revealEls.forEach(el => revealObs.observe(el));

  // Counter animation
  const counters = document.querySelectorAll('.counter');
  const cObs = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        const el = e.target;
        const target = parseInt(el.dataset.target || '0');
        const dur = 2200;
        const start = performance.now();
        (function tick(now) {
          const p = Math.min((now - start) / dur, 1);
          const eased = 1 - Math.pow(1 - p, 3);
          el.textContent = Math.round(eased * target).toLocaleString();
          if (p < 1) requestAnimationFrame(tick);
        })(start);
        cObs.unobserve(el);
      }
    });
  }, { threshold: 0.5 });
  counters.forEach(c => cObs.observe(c));

  // Project card mouse glow
  document.querySelectorAll('.project-poster').forEach(card => {
    card.addEventListener('mousemove', e => {
      const r = card.getBoundingClientRect();
      card.style.setProperty('--mx', ((e.clientX - r.left) / r.width * 100) + '%');
      card.style.setProperty('--my', ((e.clientY - r.top) / r.height * 100) + '%');
    });
  });

  // Smooth scroll for hash links
  document.querySelectorAll('a[href^="#"]').forEach(a => {
    a.addEventListener('click', (e) => {
      const href = a.getAttribute('href');
      const t = document.querySelector(href);
      if (t) {
        e.preventDefault();
        t.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
  });

})();
</script>
